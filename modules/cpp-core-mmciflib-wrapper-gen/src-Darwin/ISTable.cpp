#include <GenString.h>
#include <ISTable.h>
#include <ITTable.h>
#include <Serializer.h>
#include <__string>
#include <initializer_list>
#include <ios>
#include <iterator>
#include <locale>
#include <memory>
#include <ostream>
#include <sstream> // __str__
#include <streambuf>
#include <string>
#include <string_view>
#include <vector>

#include <pybind11/pybind11.h>

#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>);
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*);
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>);
#endif

void bind_ISTable(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // ISTable file:ISTable.h line:53
		pybind11::class_<ISTable, std::shared_ptr<ISTable>> cl(M(""), "ISTable", "*  \n\n* \n*  \n\n Public class that respresents a two-dimensional table of strings.\n* \n*  This class represents a two-dimensional table of cells. Each cell holds\n*  a text string. The table is identified by its name. Rows are horizontal\n*  table entities identified by row indices, which are unsigned integers\n*  ranging from zero to the number of rows minus one. Columns are vertical\n*  table entities identified by (non-empty) column names. Column names can\n*  be case-sensitive (by default) or case-insensitive (customizable during\n*  construction). The class provides methods for table construction and\n*  destruction, assignment operator, equal operator, column and row based\n*  methods for addition, insertion, retrieval, update, deletion, cell\n*  based methods for update and retrieval, column search methods and table\n*  printing. Table cells are internally stored as vectors of text strings,\n*  where vectors can represent either columns (by default) or rows\n*  (customizable during construction).");
		pybind11::handle cl_type = cl;

		cl.def(pybind11::init([](){ return new ISTable(); }), "doc");
		cl.def(pybind11::init<const enum Char::eCompareType>(), pybind11::arg("colCaseSense"));

		cl.def(pybind11::init([](enum ITTable::eOrientation  const &a0){ return new ISTable(a0); }), "doc");
		cl.def(pybind11::init<enum ITTable::eOrientation, const enum Char::eCompareType>(), pybind11::arg("orient"), pybind11::arg("colCaseSense"));

		cl.def(pybind11::init([](const class std::__1::basic_string<char> & a0){ return new ISTable(a0); }), "doc");
		cl.def(pybind11::init<const class std::__1::basic_string<char> &, const enum Char::eCompareType>(), pybind11::arg("name"), pybind11::arg("colCaseSense"));

		cl.def(pybind11::init([](const class std::__1::basic_string<char> & a0, enum ITTable::eOrientation  const &a1){ return new ISTable(a0, a1); }), "doc");
		cl.def(pybind11::init<const class std::__1::basic_string<char> &, enum ITTable::eOrientation, const enum Char::eCompareType>(), pybind11::arg("name"), pybind11::arg("orient"), pybind11::arg("colCaseSense"));

		cl.def(pybind11::init<ISTable const &>());
		pybind11::enum_<ISTable::eTableDiff>(cl, "eTableDiff", "")
			.value("eNONE", ISTable::eTableDiff::eNONE)
			.value("eCASE_SENSE", ISTable::eTableDiff::eCASE_SENSE)
			.value("eMORE_COLS", ISTable::eTableDiff::eMORE_COLS)
			.value("eLESS_COLS", ISTable::eTableDiff::eLESS_COLS)
			.value("eCOL_NAMES", ISTable::eTableDiff::eCOL_NAMES)
			.value("eMORE_ROWS", ISTable::eTableDiff::eMORE_ROWS)
			.value("eLESS_ROWS", ISTable::eTableDiff::eLESS_ROWS)
			.value("eCELLS", ISTable::eTableDiff::eCELLS)
			.value("eMISSING", ISTable::eTableDiff::eMISSING)
			.value("eEXTRA", ISTable::eTableDiff::eEXTRA)
			.export_values();

		cl.def("assign", (class ISTable & (ISTable::*)(const class ISTable &)) &ISTable::operator=, "*  Copies a table to another table (assignment operator).\n*\n*  \n\n - reference to the source table\n*\n*  \n\n Reference to the destination table\n*\n*  \n\n None\n*\n*  \n\n Constructed table is a clone (has the same name, internal\n*    cells orientation, case sensitivity, column names, content)\n*    as the table referenced by \n  \n\n: None\n\nC++: ISTable::operator=(const class ISTable &) --> class ISTable &", pybind11::return_value_policy::automatic, pybind11::arg("inTable"));
		cl.def("__eq__", (enum ISTable::eTableDiff (ISTable::*)(class ISTable &)) &ISTable::operator==, "*  Compares a table to another table, ignoring the table name.\n*\n*  \n\n - reference to input table\n*\n*  \n\n eNONE - if tables are identical\n*  \n\n eCASE_SENSE - if tables have different column name case\n*    sensitivity\n*  \n\n eMORE_COLS - if this table has more columns than input table\n*  \n\n eLESS_COLS - if this table has less columns than input table\n*  \n\n eCOL_NAMES - if tables have different column names\n*  \n\n eMORE_ROWS - if this table has more rows than input table\n*  \n\n eLESS_ROWS - if this table has less rows than input table\n*  \n\n eCELLS - if tables have different content\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n: None\n\nC++: ISTable::operator==(class ISTable &) --> enum ISTable::eTableDiff", pybind11::arg("inTable"));
		cl.def("GetName", (const std::string & (ISTable::*)() const) &ISTable::GetName, "*  Retrieves table name.\n*\n*  \n\n None\n*\n*  \n\n Constant reference to a string that contains table name.\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n: None\n\nC++: ISTable::GetName() const --> const std::string &", pybind11::return_value_policy::automatic);
		cl.def("SetName", (void (ISTable::*)(const std::string &)) &ISTable::SetName, "*  Changes the table name.\n*\n*  \n\n - the new name of the table\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n: None\n\nC++: ISTable::SetName(const class std::__1::basic_string<char> &) --> void", pybind11::arg("name"));
		cl.def("GetNumColumns", (unsigned int (ISTable::*)() const) &ISTable::GetNumColumns, "*  Retrieves the number of columns in the table.\n*\n*  \n\n None\n*\n*  \n\n The number of columns in the table.\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n: None\n\nC++: ISTable::GetNumColumns() const --> unsigned int");
		cl.def("GetColumnNames", (const class std::vector<std::string, class std::allocator<std::string > > & (ISTable::*)() const) &ISTable::GetColumnNames, "*  Retrieves column names.\n*\n*  \n\n - retrieved column names\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n: None\n\nC++: ISTable::GetColumnNames() const --> const class std::vector<std::string, class std::allocator<std::string > > &", pybind11::return_value_policy::automatic);
		cl.def("IsColumnPresent", (bool (ISTable::*)(const std::string &)) &ISTable::IsColumnPresent, "*  Checks for column existence.\n*\n*  \n\n - the name of the column\n*\n*  \n\n true - if column exists\n*  \n\n false - if column does not exist\n*\n*  \n\n  must be non-empty\n*\n*  \n\n None\n*\n*  \n\n EmptyValueException - if  is empty\n\nC++: ISTable::IsColumnPresent(const class std::__1::basic_string<char> &) --> bool", pybind11::arg("colName"));
		cl.def("AddColumn", [](ISTable &o, const class std::__1::basic_string<char> & a0) -> void { return o.AddColumn(a0); }, "", pybind11::arg("colName"));
		cl.def("AddColumn", (void (ISTable::*)(const std::string &, const class std::vector<std::string, class std::allocator<std::string > > &)) &ISTable::AddColumn, "*  Adds a column to the end of the table. \n*\n*  \n\n - the name of the column to be added\n*  \n\n - optional parameter that contains the values which\n*    are to be used to fill in the newly added column. If  is\n*    specified, filling starts at row index 0 and continues until size\n*    of  If  is not specified, the newly added column is\n*    filled with empty values, where filling starts at row index 0 and\n*    ends at row index \"number of rows - 1\".\n*\n*  \n\n None\n*\n*  \n\n  must be non-empty\n*  \n\n Column with name  must not be present\n*  \n\n If  is specified, the size of  must be less than or\n*    equal to the number of rows.\n*\n*  \n\n If table is empty (0 rows) and  is specified, the number of\n*    rows is set to the size of  Otherwise, the number of rows is\n*    unchanged.\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n AlreadyExistsException - if column with name \n    already exists\n*  \n\n out_of_range - if size of  is greater than the number\n*    of rows\n\nC++: ISTable::AddColumn(const class std::__1::basic_string<char> &, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> void", pybind11::arg("colName"), pybind11::arg("col"));
		cl.def("InsertColumn", [](ISTable &o, const class std::__1::basic_string<char> & a0, const class std::__1::basic_string<char> & a1) -> void { return o.InsertColumn(a0, a1); }, "", pybind11::arg("colName"), pybind11::arg("afColName"));
		cl.def("InsertColumn", (void (ISTable::*)(const std::string &, const std::string &, const class std::vector<std::string, class std::allocator<std::string > > &)) &ISTable::InsertColumn, "*  Inserts a new column at the specified existing column and shifts,\n*    to the right by one, the specified existing column and all columns\n*    after it.\n*\n*  \n\n - the name of the column to be inserted\n*  \n\n - the name of the column at which the\n*    new column is to be inserted\n*  \n\n - optional parameter that contains the values which\n*    are to be used to fill in the newly inserted column. If  is\n*    specified, filling starts at row index 0 and continues until size\n*    of  If  is not specified, the newly inserted column is\n*    filled with empty values, where filling starts at row index 0 and\n*    ends at row index \"number of rows - 1\".\n*\n*  \n\n None\n*\n*  \n\n  must be non-empty\n*  \n\n Column with name  must not be present\n*  \n\n  must be non-empty\n*  \n\n Column with name  must be present\n*  \n\n If  is specified, the size of  must be less than or\n*    equal to the number of rows.\n*  \n\n The column which comes, in order, before the column with name\n*     must be non-empty. This is to prevent creation of\n*    non-rectangular tables.\n*\n*  \n\n If table is empty (0 rows) and  is specified, the number of\n*    rows is set to the size of  Otherwise, the number of rows is\n*    unchanged.\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n AlreadyExistsException - if column with name \n    already exists\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if column with name \n    does not exist\n*  \n\n out_of_range - if size of  is greater than the number\n*    of rows\n*  \n\n out_of_range - if column, which comes, in order, before the\n*    column with name  is empty.\n\nC++: ISTable::InsertColumn(const class std::__1::basic_string<char> &, const class std::__1::basic_string<char> &, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> void", pybind11::arg("colName"), pybind11::arg("afColName"), pybind11::arg("col"));
		cl.def("FillColumn", (void (ISTable::*)(const std::string &, const class std::vector<std::string, class std::allocator<std::string > > &)) &ISTable::FillColumn, "*  Fills a column with values.\n*\n*  \n\n - the name of the column to be filled\n*  \n\n - contains the values which are to be used for filling.\n*    Filling starts at row index 0 and continues until size of \n  \n\n None\n*\n*  \n\n  must be non-empty\n*  \n\n Column with name  must be present\n*  \n\n The size of  must be less than or equal to the number of\n*    rows.\n*  \n\n The column which comes, in order, before the column with name\n*     must be non-empty. This is to prevent creation of\n*    non-rectangular tables.\n*\n*  \n\n If table is empty (0 rows), the number of rows is set to the\n*    size of  Otherwise, the number of rows is unchanged.\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if column with name \n    does not exist\n*  \n\n out_of_range - if size of  is greater than the number\n*    of rows\n*  \n\n out_of_range - if column, which comes, in order, before the\n*    column with name  is empty.\n\nC++: ISTable::FillColumn(const class std::__1::basic_string<char> &, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> void", pybind11::arg("colName"), pybind11::arg("col"));
		cl.def("GetColumn", (void (ISTable::*)(class std::vector<std::string, class std::allocator<std::string > > &, const std::string &)) &ISTable::GetColumn, "*  Retrieves column values. \n*\n*  \n\n - retrieved column values\n*  \n\n - the name of the column which content is to be\n*    retrieved.\n*\n*  \n\n None\n*\n*  \n\n  must be non-empty\n*  \n\n Column with name  must be present\n*\n*  \n\n None\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if column with name \n    does not exist\n\nC++: ISTable::GetColumn(class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const class std::__1::basic_string<char> &) --> void", pybind11::arg("col"), pybind11::arg("colName"));
		cl.def("GetColumn", (void (ISTable::*)(class std::vector<std::string, class std::allocator<std::string > > &, const std::string &, const unsigned int, unsigned int)) &ISTable::GetColumn, "*  Retrieves column values in the specified row range. \n*\n*  \n\n - retrieved values\n*  \n\n - the name of the column which content is to be\n*    retrieved.\n*  \n\n - the row index of the first cell in the\n*    column to be retrieved.\n*  \n\n - the row index of the last cell in the column\n*    to be retrieved.\n*\n*  \n\n None\n*\n*  \n\n  must be non-empty\n*  \n\n Column with name  must be present\n*  \n\n  must be less than or equal to the column length\n*  \n\n  must be less than or equal to the column length\n*  \n\n  must be less than or equal to the \n  \n\n None\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if column with name \n    does not exist\n*  \n\n out_of_range - if  is greater than the column\n*    length\n*  \n\n out_of_range - if  is greater than the column\n*    length\n*  \n\n out_of_range - if  is greater than\n*    \n    \n\nC++: ISTable::GetColumn(class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const class std::__1::basic_string<char> &, const unsigned int, unsigned int) --> void", pybind11::arg("col"), pybind11::arg("colName"), pybind11::arg("fromRowIndex"), pybind11::arg("toRowIndex"));
		cl.def("GetColumn", (void (ISTable::*)(class std::vector<std::string, class std::allocator<std::string > > &, const std::string &, const class std::vector<unsigned int, class std::allocator<unsigned int> > &)) &ISTable::GetColumn, "*  Retrieves column values in the specified rows. \n*\n*  \n\n - retrieved values\n*  \n\n - the name of the column which content is to be\n*    retrieved\n*  \n\n - row indices of column cells to be retrieved\n*\n*  \n\n None\n*\n*  \n\n  must be non-empty\n*  \n\n Column with name  must be present\n*  \n\n Row indices in  must be less than or equal to the\n*    column length\n*\n*  \n\n None\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if column with name \n    does not exist\n*  \n\n out_of_range - if at least one row index in  is\n*    greater than the column length\n\nC++: ISTable::GetColumn(class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const class std::__1::basic_string<char> &, const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &) --> void", pybind11::arg("col"), pybind11::arg("colName"), pybind11::arg("rowIndex"));
		cl.def("RenameColumn", (void (ISTable::*)(const std::string &, const std::string &)) &ISTable::RenameColumn, "*  Changes the column name.\n*\n*  \n\n - the name of the column which is to be renamed\n*  \n\n - the new column name\n*\n*  \n\n None\n*\n*  \n\n  must be non-empty\n*  \n\n Column with name  must be present\n*  \n\n  must be non-empty\n*  \n\n Column with name  must not be present\n*\n*  \n\n None\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if column with name \n    does not exist\n*  \n\n EmptyValueException - if  is empty\n*  \n\n AlreadyExistsException - if column with name \n    already exists\n\nC++: ISTable::RenameColumn(const class std::__1::basic_string<char> &, const class std::__1::basic_string<char> &) --> void", pybind11::arg("oldColName"), pybind11::arg("newColName"));
		cl.def("ClearColumn", (void (ISTable::*)(const std::string &)) &ISTable::ClearColumn, "*  Sets all cells in the column to empty string.\n*\n*  \n\n - the name of the column\n*\n*  \n\n None\n*\n*  \n\n  must be non-empty\n*  \n\n Column with name  must be present\n*\n*  \n\n Column length is unchanged.\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if column with name \n    does not exist\n\nC++: ISTable::ClearColumn(const class std::__1::basic_string<char> &) --> void", pybind11::arg("colName"));
		cl.def("DeleteColumn", (void (ISTable::*)(const std::string &)) &ISTable::DeleteColumn, "*  Deletes a column from the table.\n*\n*  \n\n - the name of the column\n*\n*  \n\n None\n*\n*  \n\n  must be non-empty\n*  \n\n Column with name  must be present\n*\n*  \n\n The number of table columns is reduced by one.\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if column with name \n    does not exist\n\nC++: ISTable::DeleteColumn(const class std::__1::basic_string<char> &) --> void", pybind11::arg("colName"));
		cl.def("GetNumRows", (unsigned int (ISTable::*)() const) &ISTable::GetNumRows, "*  Retrieves the number of rows in the table.\n*\n*  \n\n None\n*\n*  \n\n The number of rows in the table.\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n: None\n\nC++: ISTable::GetNumRows() const --> unsigned int");
		cl.def("AddRow", [](ISTable &o) -> unsigned int { return o.AddRow(); }, "");
		cl.def("AddRow", (unsigned int (ISTable::*)(const class std::vector<std::string, class std::allocator<std::string > > &)) &ISTable::AddRow, "*  Adds a row to the end of the table. For an empty table (0 rows),\n*  the number of inserted cells is equal to the number of table columns.\n*  For a non-empty table, the number of inserted cells is equal to the\n*  number of non-empty columns (this is in order to prevent creation of\n*  non-rectangular tables). The newly added row is, optionally, filled\n*  with values, starting at the first column.\n*\n*  \n\n - optional parameter that contains the values which\n*    are to be used to fill in the newly added row. If  is\n*    specified, filling starts at the first column and continues until\n*    size of  is reached. If  is not specified and table is\n*    empty, the newly inserted row is filled with empty values,\n*    where filling starts at the first column and continues until the\n*    number of columns is reached.  If  is not specified and table\n*    is not empty, the newly inserted row is filled with empty values,\n*    where filling starts at the first column and continues until the\n*    number of non-empty columns is reached.\n*\n*  \n\n The new number of rows after the row addition.\n*\n*  \n\n Table must have at least one column, which can be empty.\n*  \n\n If table is not empty and  is specified, the size of \n    must be less than or equal to the number of non-empty columns.\n*    This is in order to prevent creation of non-rectangular tables.\n*  \n\n If table is empty and  is specified, the size of  must\n*    be less than or equal to the number of columns.\n*\n*  \n\n The number of rows is increased by one. \n*\n*  \n\n EmptyContainerException - if table has no columns.\n*  \n\n out_of_range - if table is not empty and size of  is\n*    greater than the number of non-empty columns.\n*  \n\n out_of_range - if table is empty and size of  is\n*    greater than the number of columns.\n\nC++: ISTable::AddRow(const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> unsigned int", pybind11::arg("row"));
		cl.def("InsertRow", [](ISTable &o, const unsigned int  &a0) -> unsigned int { return o.InsertRow(a0); }, "", pybind11::arg("atRowIndex"));
		cl.def("InsertRow", (unsigned int (ISTable::*)(const unsigned int, const class std::vector<std::string, class std::allocator<std::string > > &)) &ISTable::InsertRow, "*  Inserts a row at the specified row index and shifts, down by one,\n*  the old row and all other rows below it. For an empty table (0 rows),\n*  the number of inserted cells is equal to the number of table columns.\n*  For a non-empty table, the number of inserted cells is equal to the\n*  number of non-empty columns (this is in order to prevent creation of\n*  non-rectangular tables). The newly inserted row is optionally filled\n*  with values, starting at the first column.\n*\n*  \n\n - index of the row at which the new row is to be\n*    inserted. Note: If  is equal to the number of rows, the\n*    operation of this method is equivalent to AddRow().\n*  \n\n - optional parameter that contains the values which\n*    are to be used to fill in the newly inserted row. If  is\n*    specified, filling starts at the first column and continues until\n*    size of  is reached. If  is not specified and table is\n*    empty, the newly inserted row is filled with empty values,\n*    where filling starts at the first column and continues until the\n*    number of columns is reached.  If  is not specified and table\n*    is not empty, the newly inserted row is filled with empty values,\n*    where filling starts at the first column and continues until the\n*    number of non-empty columns is reached.\n*\n*  \n\n The new number of rows after the row insertion.\n*\n*  \n\n Table must have at least one column, which can be empty.\n*  \n\n  must be greater than or equal to 0 and less than\n*    or equal to the number of table rows.\n*  \n\n If table is not empty and  is specified, the size of \n    must be less than or equal to the number of non-empty columns.\n*    This is in order to prevent creation of non-rectangular tables.\n*  \n\n If table is empty and  is specified, the size of  must\n*    be less than or equal to the number of columns.\n*\n*  \n\n The number of rows is increased by one. \n*  \n\n Row indices, of the rows below the inserted row, are invalidated\n*    by being increased by one.\n*\n*  \n\n EmptyContainerException - if table has no columns.\n*  \n\n out_of_range - if  is greater than the number\n*    of table rows.\n*  \n\n out_of_range - if table is not empty and size of  is\n*    greater than the number of non-empty columns.\n*  \n\n out_of_range - if table is empty and size of  is\n*    greater than the number of columns.\n\nC++: ISTable::InsertRow(const unsigned int, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> unsigned int", pybind11::arg("atRowIndex"), pybind11::arg("row"));
		cl.def("FillRow", (void (ISTable::*)(const unsigned int, const class std::vector<std::string, class std::allocator<std::string > > &)) &ISTable::FillRow, "*  Fills, with values, a row at the specified row index, starting at the\n*  the first column.\n*\n*  \n\n - index of the row that is to be filled.\n*  \n\n - values which are to be used to fill in the row.\n*    Filling starts at the first column and continues until size of\n*     is reached.\n*\n*  \n\n None\n*\n*  \n\n  must be greater than or equal to 0 and less than\n*    the number of table rows.\n*  \n\n The size of  must be less than or equal to the number of\n*    non-empty columns. This is in order to prevent creation of\n*    non-rectangular tables.\n*\n*  \n\n None \n*\n*  \n\n out_of_range - if  is greater than or equal to\n*    the number of table rows.\n*  \n\n out_of_range - if size of  is greater than the number\n*    of non-empty columns.\n\nC++: ISTable::FillRow(const unsigned int, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> void", pybind11::arg("rowIndex"), pybind11::arg("row"));
		cl.def("GetRow", [](ISTable &o, class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a0, const unsigned int  &a1) -> void { return o.GetRow(a0, a1); }, "", pybind11::arg("row"), pybind11::arg("rowIndex"));
		cl.def("GetRow", [](ISTable &o, class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a0, const unsigned int  &a1, const class std::__1::basic_string<char> & a2) -> void { return o.GetRow(a0, a1, a2); }, "", pybind11::arg("row"), pybind11::arg("rowIndex"), pybind11::arg("fromColName"));
		cl.def("GetRow", (void (ISTable::*)(class std::vector<std::string, class std::allocator<std::string > > &, const unsigned int, const std::string &, const std::string &)) &ISTable::GetRow, "*  Retrieves row values. \n*\n*  \n\n - retrieved row values\n*  \n\n - index of the row which values are to be\n*    retrieved.\n*  \n\n - optional parameter which specifies the\n*    location of the first cell to be retrieved. If not specified\n*    the first column cell is used.\n*  \n\n - optional parameter which specifies the\n*    location of the last cell to be retrieved. If not specified\n*    the last non-empty-column cell is used.\n*\n*  \n\n None\n*\n*  \n\n  must be greater than or equal to 0 and less than\n*    the number of table rows.\n*  \n\n If  is specified, the column with name\n*     must be present and must be non-empty\n*  \n\n If  is specified, the column with name\n*     must be present and must be non-empty\n*  \n\n If  is different than  it must come\n*    prior to it in the column order.\n*\n*  \n\n None\n*\n*  \n\n out_of_range - if  is greater than or equal to\n*    the number of table rows.\n*  \n\n NotFoundException - If  is specified and\n*    column with name  does not exist\n*  \n\n NotFoundException - If  is specified and\n*    column with name  does not exist\n*  \n\n out_of_range - If  is specified and\n*    column with name  exists but is empty\n*  \n\n out_of_range - If  is specified and\n*    column with name  exists but is empty\n*  \n\n out_of_range - if  is different than\n*     and it comes after it in the column order.\n\nC++: ISTable::GetRow(class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const unsigned int, const class std::__1::basic_string<char> &, const class std::__1::basic_string<char> &) --> void", pybind11::arg("row"), pybind11::arg("rowIndex"), pybind11::arg("fromColName"), pybind11::arg("toColName"));
		cl.def("GetRow", (const class std::vector<std::string, class std::allocator<std::string > > & (ISTable::*)(const unsigned int)) &ISTable::GetRow, "*  Retrieves a constant reference to a row of values the table.\n*\n*  \n\n - index of a row to which a reference is to be\n*    retrieved.\n*\n*  \n\n Constant reference to the row of values in the table.\n*\n*  \n\n  must be greater than or equal to 0 and less than\n*    the number of table rows.\n*\n*  \n\n None\n*\n*  \n\n out_of_range - if  is greater than or equal to\n*    the number of table rows.\n\nC++: ISTable::GetRow(const unsigned int) --> const class std::vector<std::string, class std::allocator<std::string > > &", pybind11::return_value_policy::automatic, pybind11::arg("rowIndex"));
		cl.def("ClearRow", (void (ISTable::*)(const unsigned int)) &ISTable::ClearRow, "*  Sets all cells in the row to empty string.\n*\n*  \n\n - index of the row that is to be cleared.\n*\n*  \n\n None\n*\n*  \n\n  must be greater than or equal to 0 and less than\n*    the number of table rows.\n*\n*  \n\n Number of table rows is unchanged.\n*\n*  \n\n out_of_range - if  is greater than or equal to\n     the number of table rows.\n\nC++: ISTable::ClearRow(const unsigned int) --> void", pybind11::arg("rowIndex"));
		cl.def("DeleteRow", (void (ISTable::*)(const unsigned int)) &ISTable::DeleteRow, "*  Deletes a row with the specified index and shifts, up by one,\n*  all other rows below it.\n*\n*  \n\n - index of the row that is to be deleted.\n*\n*  \n\n None\n*\n*  \n\n  must be greater than or equal to 0 and less than\n*    the number of table rows.\n*\n*  \n\n Number of table rows is reduced by one.\n*  \n\n Row indices of the rows which are below the deleted row are\n*    invalidated by being reduced by one.\n*\n*  \n\n out_of_range - if  is greater than or equal to\n*    the number of table rows.\n\nC++: ISTable::DeleteRow(const unsigned int) --> void", pybind11::arg("rowIndex"));
		cl.def("DeleteRows", (void (ISTable::*)(const class std::vector<unsigned int, class std::allocator<unsigned int> > &)) &ISTable::DeleteRows, "*  Deletes rows with specified indices.\n*\n*  \n\n - indices of rows that are to be deleted.\n*\n*  \n\n None\n*\n*  \n\n indices in  must be greater than or equal to 0 and less\n*    than the number of table rows.\n*\n*  \n\n Number of table rows is reduced by the size of \n  \n\n Row indices of the remaining rows are invalidated by being\n*    appropriatelly adjusted.\n*\n*  \n\n out_of_range - if any row index in  is greater than\n*    or equal to the number of table rows.\n\nC++: ISTable::DeleteRows(const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &) --> void", pybind11::arg("rows"));
		cl.def("GetLastRowIndex", (unsigned int (ISTable::*)()) &ISTable::GetLastRowIndex, "*  Retrieves the row index of the last row in the table.\n*\n*  \n\n None\n*\n*  \n\n The index of the last row in the table.\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n: None\n\nC++: ISTable::GetLastRowIndex() --> unsigned int");
		cl.def("UpdateCell", (void (ISTable::*)(const unsigned int, const std::string &, const std::string &)) &ISTable::UpdateCell, "*  Updates a cell in the table.\n*\n*  \n\n - row index of the cell that is to be updated\n*  \n\n - the name of the column of the cell that is to be\n*    updated\n*  \n\n - the new value\n*\n*  \n\n None\n*\n*  \n\n  must be greater than or equal to 0 and less than\n*    the number of table rows.\n*  \n\n  must be non-empty\n*  \n\n Column with name  must be present\n*\n*  \n\n None\n*\n*  \n\n out_of_range - if  is greater than or equal\n*    to the number of table rows.\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if column with name \n    does not exist\n\nC++: ISTable::UpdateCell(const unsigned int, const class std::__1::basic_string<char> &, const class std::__1::basic_string<char> &) --> void", pybind11::arg("rowIndex"), pybind11::arg("colName"), pybind11::arg("value"));
		cl.def("__call__", (const std::string & (ISTable::*)(const unsigned int, const std::string &) const) &ISTable::operator(), "*  Retrieves a constant reference to the cell in the table.\n*\n*  \n\n - row index of the cell\n*  \n\n - the name of the column of the cell\n*\n*  \n\n Constant reference to the cell in the table.\n*\n*  \n\n  must be greater than or equal to 0 and less than\n*    the number of table rows.\n*  \n\n  must be non-empty\n*  \n\n Column with name  must be present\n*\n*  \n\n None\n*\n*  \n\n out_of_range - if  is greater than or equal\n*    to the number of table rows.\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if column with name \n    does not exist\n\nC++: ISTable::operator()(const unsigned int, const class std::__1::basic_string<char> &) const --> const std::string &", pybind11::return_value_policy::automatic, pybind11::arg("rowIndex"), pybind11::arg("colName"));
		cl.def("SetFlags", (void (ISTable::*)(const std::string &, const unsigned char)) &ISTable::SetFlags, "*  Sets column flags that are only used in column search. These flags\n*  control how cell values in a column are interpreted at the time of\n*  search. They can be interpreted as strings or integers, as\n*   case-sensitive or case-insensitive strings, as space-ignoring\n*  or space-non-ignoring strings. Multiple flags can be specified using\n*  \"|\" operator when invoking this method.\n*\n*  \n\n - the name of the column\n*  \n\n - column search flags. It can have any or multiple\n*    \"or\"-ed values of: DT_STRING, DT_INTEGER, CASE_SENSE, CASE_INSENSE,\n*    W_SPACE_SENSE, W_SPACE_INSENSE.\n*\n*  \n\n None\n*\n*  \n\n  must be non-empty\n*  \n\n Column with name  must be present\n*\n*  \n\n None\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if column with name \n    does not exist\n\nC++: ISTable::SetFlags(const class std::__1::basic_string<char> &, const unsigned char) --> void", pybind11::arg("colName"), pybind11::arg("flags"));
		cl.def("GetDataType", (unsigned char (ISTable::*)(const std::string &)) &ISTable::GetDataType, "*  Retrieves data type flag of a column.\n*\n*  \n\n - the name of the column\n*\n*  \n\n DT_STRING_VAL - if data type of a column is string.\n*  \n\n DT_INTEGER_VAL - if data type of a column is integer.\n*\n*  \n\n  must be non-empty\n*  \n\n Column with name  must be present\n*\n*  \n\n None\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if column with name \n    does not exist\n\nC++: ISTable::GetDataType(const class std::__1::basic_string<char> &) --> unsigned char", pybind11::arg("colName"));
		cl.def("FindFirst", [](ISTable &o, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a0, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a1) -> unsigned int { return o.FindFirst(a0, a1); }, "", pybind11::arg("targets"), pybind11::arg("colNames"));
		cl.def("FindFirst", (unsigned int (ISTable::*)(const class std::vector<std::string, class std::allocator<std::string > > &, const class std::vector<std::string, class std::allocator<std::string > > &, const std::string &)) &ISTable::FindFirst, "*  Searches the columns for the first occurrence of target values and\n*  returns the row index, where the match was found. The performed search\n*  is a forward search (starts at row index 0) and search criteria is\n*  value equality. If match was not found, the number of table rows\n*  is returned.\n*\n*  \n\n - values that are to be searched for\n*  \n\n - column names that are to be searched\n*  \n\n - optional parameter not used and will be soon\n*    be removed\n*\n*  \n\n the first row index, where the match was found\n*  \n\n the number of rows, if the match was not found\n*\n*  \n\n Each column name in  must be non-empty\n*  \n\n Each column name in  must be present\n*  \n\n  and  must have the same size\n*\n*  \n\n None\n*\n*  \n\n EmptyValueException - if one or more column names in\n*     is empty\n*  \n\n NotFoundException - if one or more column names in\n*     does not exist\n*  \n\n out_of_range - if  and  have\n*    different sizes\n\nC++: ISTable::FindFirst(const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const class std::__1::basic_string<char> &) --> unsigned int", pybind11::arg("targets"), pybind11::arg("colNames"), pybind11::arg("indexName"));
		cl.def("Search", [](ISTable &o, class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > & a0, const class std::__1::basic_string<char> & a1, const class std::__1::basic_string<char> & a2) -> void { return o.Search(a0, a1, a2); }, "", pybind11::arg("res"), pybind11::arg("target"), pybind11::arg("colName"));
		cl.def("Search", [](ISTable &o, class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > & a0, const class std::__1::basic_string<char> & a1, const class std::__1::basic_string<char> & a2, const unsigned int  &a3) -> void { return o.Search(a0, a1, a2, a3); }, "", pybind11::arg("res"), pybind11::arg("target"), pybind11::arg("colName"), pybind11::arg("fromRowIndex"));
		cl.def("Search", [](ISTable &o, class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > & a0, const class std::__1::basic_string<char> & a1, const class std::__1::basic_string<char> & a2, const unsigned int  &a3, const enum ITTable::eSearchDir  &a4) -> void { return o.Search(a0, a1, a2, a3, a4); }, "", pybind11::arg("res"), pybind11::arg("target"), pybind11::arg("colName"), pybind11::arg("fromRowIndex"), pybind11::arg("searchDir"));
		cl.def("Search", (void (ISTable::*)(class std::vector<unsigned int, class std::allocator<unsigned int> > &, const std::string &, const std::string &, const unsigned int, const enum ITTable::eSearchDir, const enum ITTable::eSearchType)) &ISTable::Search, "*  Searches one column for all occurrences of target value and\n*  returns row indices, where the match was found.\n*\n*  \n\n - vector of row indices, where the match was found\n*  \n\n - value that is to be searched for\n*  \n\n - column name that is to be searched\n*  \n\n - optional parameter that specifies search\n*    criteria: equality, less than, less than or equal, greater than,\n*    greater than or equal. These are the text strings search criteria.\n*    If not specified, the search criteria is equality.\n*\n*  \n\n None\n*\n*  \n\n  must be non-empty\n*  \n\n Column with name  must be present\n*\n*  \n\n None\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if column with name \n    does not exist\n\nC++: ISTable::Search(class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, const class std::__1::basic_string<char> &, const class std::__1::basic_string<char> &, const unsigned int, const enum ITTable::eSearchDir, const enum ITTable::eSearchType) --> void", pybind11::arg("res"), pybind11::arg("target"), pybind11::arg("colName"), pybind11::arg("fromRowIndex"), pybind11::arg("searchDir"), pybind11::arg("searchType"));
		cl.def("Search", [](ISTable &o, class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > & a0, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a1, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a2) -> void { return o.Search(a0, a1, a2); }, "", pybind11::arg("res"), pybind11::arg("targets"), pybind11::arg("colNames"));
		cl.def("Search", [](ISTable &o, class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > & a0, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a1, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a2, const unsigned int  &a3) -> void { return o.Search(a0, a1, a2, a3); }, "", pybind11::arg("res"), pybind11::arg("targets"), pybind11::arg("colNames"), pybind11::arg("fromRowIndex"));
		cl.def("Search", [](ISTable &o, class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > & a0, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a1, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a2, const unsigned int  &a3, const enum ITTable::eSearchDir  &a4) -> void { return o.Search(a0, a1, a2, a3, a4); }, "", pybind11::arg("res"), pybind11::arg("targets"), pybind11::arg("colNames"), pybind11::arg("fromRowIndex"), pybind11::arg("searchDir"));
		cl.def("Search", [](ISTable &o, class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > & a0, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a1, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a2, const unsigned int  &a3, const enum ITTable::eSearchDir  &a4, const enum ITTable::eSearchType  &a5) -> void { return o.Search(a0, a1, a2, a3, a4, a5); }, "", pybind11::arg("res"), pybind11::arg("targets"), pybind11::arg("colNames"), pybind11::arg("fromRowIndex"), pybind11::arg("searchDir"), pybind11::arg("searchType"));
		cl.def("Search", (void (ISTable::*)(class std::vector<unsigned int, class std::allocator<unsigned int> > &, const class std::vector<std::string, class std::allocator<std::string > > &, const class std::vector<std::string, class std::allocator<std::string > > &, const unsigned int, const enum ITTable::eSearchDir, const enum ITTable::eSearchType, const std::string &)) &ISTable::Search, "*  Searches the columns for all occurrences of target values and\n*  returns row indices, where the match was found.\n*\n*  \n\n - vector of row indices, where the match was found\n*  \n\n - values that are to be searched for\n*  \n\n - column names that are to be searched\n*  \n\n - optional parameter that specifies search\n*    criteria: equality, less than, less than or equal, greater than,\n*    greater than or equal. These are the text strings search criteria.\n*    If not specified, the search criteria is equality.\n*  \n\n - optional parameter not used and will be soon\n*    be removed.\n*\n*  \n\n None\n*\n*  \n\n Each column name in  must be non-empty\n*  \n\n Each column name in  must be present\n*  \n\n  and  must have the same size\n*\n*  \n\n None\n*\n*  \n\n EmptyValueException - if one or more column names in\n*     is empty\n*  \n\n NotFoundException - if one or more column names in\n*     does not exist\n*  \n\n out_of_range - if  and  have\n*    different sizes\n\nC++: ISTable::Search(class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const unsigned int, const enum ITTable::eSearchDir, const enum ITTable::eSearchType, const class std::__1::basic_string<char> &) --> void", pybind11::arg("res"), pybind11::arg("targets"), pybind11::arg("colNames"), pybind11::arg("fromRowIndex"), pybind11::arg("searchDir"), pybind11::arg("searchType"), pybind11::arg("indexName"));
		cl.def("GetColCaseSense", (enum Char::eCompareType (ISTable::*)() const) &ISTable::GetColCaseSense, "*  Retrieves case sensitivity of column names.\n*\n*  \n\n None\n*\n*  \n\n eCASE_SENSITIVE - if case sensitive\n*  \n\n eCASE_INSENSITIVE - if case in-sensitive\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n: None\n\nC++: ISTable::GetColCaseSense() const --> enum Char::eCompareType");
		cl.def("SetModified", (void (ISTable::*)(const bool)) &ISTable::SetModified, "*  Utility method, not part of users public API.\n\nC++: ISTable::SetModified(const bool) --> void", pybind11::arg("modified"));
		cl.def("GetModified", (bool (ISTable::*)()) &ISTable::GetModified, "*  Utility method, not part of users public API.\n\nC++: ISTable::GetModified() --> bool");
		cl.def("SetSerializer", (void (ISTable::*)(class Serializer *)) &ISTable::SetSerializer, "*  Utility method, not part of users public API.\n\nC++: ISTable::SetSerializer(class Serializer *) --> void", pybind11::arg("ser"));
		cl.def("WriteObject", (int (ISTable::*)(class Serializer *, int &)) &ISTable::WriteObject, "*  Utility method, not part of users public API.\n\nC++: ISTable::WriteObject(class Serializer *, int &) --> int", pybind11::arg("ser"), pybind11::arg("size"));
		cl.def("GetObject", (int (ISTable::*)(unsigned int, class Serializer *)) &ISTable::GetObject, "*  Utility method, not part of users public API.\n\nC++: ISTable::GetObject(unsigned int, class Serializer *) --> int", pybind11::arg("index"), pybind11::arg("ser"));
		cl.def("Read", (void (ISTable::*)(unsigned int)) &ISTable::Read, "*  Utility method, not part of users public API.\n\nC++: ISTable::Read(unsigned int) --> void", pybind11::arg("indexInFile"));
		cl.def("Write", (int (ISTable::*)()) &ISTable::Write, "*  Utility method, not part of users public API.\n\nC++: ISTable::Write() --> int");
		cl.def_static("Merge", [](class ISTable & a0, class ISTable & a1) -> ISTable * { return ISTable::Merge(a0, a1); }, "", pybind11::return_value_policy::automatic, pybind11::arg("firstTable"), pybind11::arg("secondTable"));
		cl.def_static("Merge", (class ISTable * (*)(class ISTable &, class ISTable &, unsigned int)) &ISTable::Merge, "*  Utility method, not part of users public API.\n\nC++: ISTable::Merge(class ISTable &, class ISTable &, unsigned int) --> class ISTable *", pybind11::return_value_policy::automatic, pybind11::arg("firstTable"), pybind11::arg("secondTable"), pybind11::arg("typeOfMerge"));
		cl.def("PrintDiff", (bool (ISTable::*)(class ISTable &)) &ISTable::PrintDiff, "*  Utility method, not part of users public API.\n\nC++: ISTable::PrintDiff(class ISTable &) --> bool", pybind11::arg("inTable"));
		cl.def("IndexExists", (bool (ISTable::*)(const std::string &)) &ISTable::IndexExists, "*  Utility method, not part of users public API.\n\nC++: ISTable::IndexExists(const class std::__1::basic_string<char> &) --> bool", pybind11::arg("indexName"));
		cl.def("CreateIndex", [](ISTable &o, const class std::__1::basic_string<char> & a0, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a1) -> void { return o.CreateIndex(a0, a1); }, "", pybind11::arg("indexName"), pybind11::arg("colNames"));
		cl.def("CreateIndex", (void (ISTable::*)(const std::string &, const class std::vector<std::string, class std::allocator<std::string > > &, const unsigned int)) &ISTable::CreateIndex, "*  Utility method, not part of users public API.\n\nC++: ISTable::CreateIndex(const class std::__1::basic_string<char> &, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const unsigned int) --> void", pybind11::arg("indexName"), pybind11::arg("colNames"), pybind11::arg("unique"));
		cl.def("DeleteIndex", (void (ISTable::*)(const std::string &)) &ISTable::DeleteIndex, "*  Utility method, not part of users public API.\n\nC++: ISTable::DeleteIndex(const class std::__1::basic_string<char> &) --> void", pybind11::arg("indexName"));
		cl.def("GetNumIndices", (unsigned int (ISTable::*)()) &ISTable::GetNumIndices, "*  Utility method, not part of users public API.\n\nC++: ISTable::GetNumIndices() --> unsigned int");
		cl.def("CreateKey", (void (ISTable::*)(const class std::vector<std::string, class std::allocator<std::string > > &)) &ISTable::CreateKey, "*  Utility method, not part of users public API.\n\nC++: ISTable::CreateKey(const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> void", pybind11::arg("colNames"));
		cl.def("DeleteKey", (void (ISTable::*)()) &ISTable::DeleteKey, "*  Utility method, not part of users public API.\n\nC++: ISTable::DeleteKey() --> void");
		cl.def_static("SetUnion", (void (*)(const class std::vector<unsigned int, class std::allocator<unsigned int> > &, const class std::vector<unsigned int, class std::allocator<unsigned int> > &, class std::vector<unsigned int, class std::allocator<unsigned int> > &)) &ISTable::SetUnion, "*  Utility method, not part of users public API.\n\nC++: ISTable::SetUnion(const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &) --> void", pybind11::arg("a"), pybind11::arg("b"), pybind11::arg("ret"));
		cl.def_static("SetIntersect", (void (*)(const class std::vector<unsigned int, class std::allocator<unsigned int> > &, const class std::vector<unsigned int, class std::allocator<unsigned int> > &, class std::vector<unsigned int, class std::allocator<unsigned int> > &)) &ISTable::SetIntersect, "*  Utility method, not part of users public API.\n\nC++: ISTable::SetIntersect(const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &) --> void", pybind11::arg("a"), pybind11::arg("b"), pybind11::arg("ret"));
		cl.def("GetColumnsIndices", (void (ISTable::*)(class std::vector<unsigned int, class std::allocator<unsigned int> > &, const class std::vector<std::string, class std::allocator<std::string > > &)) &ISTable::GetColumnsIndices, "*  Utility method, not part of users public API.\n\nC++: ISTable::GetColumnsIndices(class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> void", pybind11::arg("colIndices"), pybind11::arg("colNames"));
		cl.def("GetColumn", (void (ISTable::*)(class std::vector<std::string, class std::allocator<std::string > > &, const std::string &, const std::string &)) &ISTable::GetColumn, "*  Utility method, not part of users public API.\n\nC++: ISTable::GetColumn(class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const class std::__1::basic_string<char> &, const class std::__1::basic_string<char> &) --> void", pybind11::arg("col"), pybind11::arg("colName"), pybind11::arg("indexName"));

		cl.def("__str__", [](ISTable const &o) -> std::string { std::ostringstream s; s << o; return s.str(); } );
	}
}
