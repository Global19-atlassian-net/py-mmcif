#include <ITTable.h>
#include <Serializer.h>
#include <__string>
#include <initializer_list>
#include <ios>
#include <iterator>
#include <locale>
#include <memory>
#include <ostream>
#include <sstream> // __str__
#include <streambuf>
#include <string>
#include <string_view>
#include <vector>

#include <pybind11/pybind11.h>

#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>);
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*);
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>);
#endif

void bind_ITTable(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // ITTable file:ITTable.h line:51
		pybind11::class_<ITTable, std::shared_ptr<ITTable>> cl(M(""), "ITTable", "*  \n\n* \n*  \n\n Private class that respresents a two-dimensional table of strings.\n* \n*  This class represents a two-dimensional table of cells. Each cell holds\n*  a text string. The table is identified by its name. Rows are horizontal\n*  table entities identified by row indices, which are unsigned integers\n*  ranging from zero to the number of rows minus one. Columns are vertical\n*  table entities identified by (non-empty) column names. Column names can\n*  be case-sensitive (by default) or case-insensitive (customizable during\n*  construction). The class provides methods for table construction and\n*  destruction, assignment operator, equal operator, column and row based\n*  methods for addition, insertion, retrieval, update, deletion, cell\n*  based methods for update and retrieval, column search methods and table\n*  printing. Table cells are internally stored as vectors of text strings,\n*  where vectors can represent either columns (by default) or rows\n*  (customizable during construction).");
		pybind11::handle cl_type = cl;

		cl.def( pybind11::init( [](){ return new ITTable(); } ) );
		cl.def(pybind11::init<enum ITTable::eOrientation>(), pybind11::arg("orient"));

		cl.def(pybind11::init<ITTable const &>());
		pybind11::enum_<ITTable::eOrientation>(cl, "eOrientation", "")
			.value("eCOLUMN_WISE", ITTable::eOrientation::eCOLUMN_WISE)
			.value("eROW_WISE", ITTable::eOrientation::eROW_WISE)
			.export_values();

		pybind11::enum_<ITTable::eSearchType>(cl, "eSearchType", "")
			.value("eEQUAL", ITTable::eSearchType::eEQUAL)
			.value("eLESS_THAN", ITTable::eSearchType::eLESS_THAN)
			.value("eLESS_THAN_OR_EQUAL", ITTable::eSearchType::eLESS_THAN_OR_EQUAL)
			.value("eGREATER_THAN", ITTable::eSearchType::eGREATER_THAN)
			.value("eGREATER_THAN_OR_EQUAL", ITTable::eSearchType::eGREATER_THAN_OR_EQUAL)
			.export_values();

		pybind11::enum_<ITTable::eSearchDir>(cl, "eSearchDir", "")
			.value("eFORWARD", ITTable::eSearchDir::eFORWARD)
			.value("eBACKWARD", ITTable::eSearchDir::eBACKWARD)
			.export_values();

		cl.def("assign", (class ITTable & (ITTable::*)(const class ITTable &)) &ITTable::operator=, "*  Copies a table to another table (assignment operator).\n*\n*  \n\n - reference to the source table\n*\n*  \n\n Reference to the destination table\n*\n*  \n\n None\n*\n*  \n\n Constructed table is a clone (has the same name, internal\n*    cells orientation, case sensitivity, column names, content)\n*    as the table referenced by \n  \n\n: None\n\nC++: ITTable::operator=(const class ITTable &) --> class ITTable &", pybind11::return_value_policy::automatic, pybind11::arg("inTable"));
		cl.def("GetNumColumns", (unsigned int (ITTable::*)() const) &ITTable::GetNumColumns, "*  Retrieves the number of columns in the table.\n*\n*  \n\n None\n*\n*  \n\n The number of columns in the table.\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n: None\n\nC++: ITTable::GetNumColumns() const --> unsigned int");
		cl.def("GetNumRows", (unsigned int (ITTable::*)() const) &ITTable::GetNumRows, "*  Retrieves the number of rows in the table.\n*\n*  \n\n None\n*\n*  \n\n The number of rows in the table.\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n: None\n\nC++: ITTable::GetNumRows() const --> unsigned int");
		cl.def("AddRow", [](ITTable &o) -> unsigned int { return o.AddRow(); }, "");
		cl.def("AddRow", (unsigned int (ITTable::*)(const class std::vector<std::string, class std::allocator<std::string > > &)) &ITTable::AddRow, "*  Adds a row to the end of the table. For an empty table (0 rows),\n*  the number of inserted cells is equal to the number of table columns.\n*  For a non-empty table, the number of inserted cells is equal to the\n*  number of non-empty columns (this is in order to prevent creation of\n*  non-rectangular tables). The newly added row is, optionally, filled\n*  with values, starting at the first column.\n*\n*  \n\n - optional parameter that contains the values which\n*    are to be used to fill in the newly added row. If  is\n*    specified, filling starts at the first column and continues until\n*    size of  is reached. If  is not specified and table is\n*    empty, the newly inserted row is filled with empty values,\n*    where filling starts at the first column and continues until the\n*    number of columns is reached.  If  is not specified and table\n*    is not empty, the newly inserted row is filled with empty values,\n*    where filling starts at the first column and continues until the\n*    number of non-empty columns is reached.\n*\n*  \n\n The new number of rows after the row addition.\n*\n*  \n\n Table must have at least one column, which can be empty.\n*  \n\n If table is not empty and  is specified, the size of \n    must be less than or equal to the number of non-empty columns.\n*    This is in order to prevent creation of non-rectangular tables.\n*  \n\n If table is empty and  is specified, the size of  must\n*    be less than or equal to the number of columns.\n*\n*  \n\n The number of rows is increased by one. \n*\n*  \n\n EmptyContainerException - if table has no columns.\n*  \n\n out_of_range - if table is not empty and size of  is\n*    greater than the number of non-empty columns.\n*  \n\n out_of_range - if table is empty and size of  is\n*    greater than the number of columns.\n\nC++: ITTable::AddRow(const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> unsigned int", pybind11::arg("row"));
		cl.def("InsertRow", [](ITTable &o, const unsigned int  &a0) -> unsigned int { return o.InsertRow(a0); }, "", pybind11::arg("atRowIndex"));
		cl.def("InsertRow", (unsigned int (ITTable::*)(const unsigned int, const class std::vector<std::string, class std::allocator<std::string > > &)) &ITTable::InsertRow, "*  Inserts a row at the specified row index and shifts, down by one,\n*  the old row and all other rows below it. For an empty table (0 rows),\n*  the number of inserted cells is equal to the number of table columns.\n*  For a non-empty table, the number of inserted cells is equal to the\n*  number of non-empty columns (this is in order to prevent creation of\n*  non-rectangular tables). The newly inserted row is optionally filled\n*  with values, starting at the first column.\n*\n*  \n\n - index of the row at which the new row is to be\n*    inserted. Note: If  is equal to the number of rows, the\n*    operation of this method is equivalent to AddRow().\n*  \n\n - optional parameter that contains the values which\n*    are to be used to fill in the newly inserted row. If  is\n*    specified, filling starts at the first column and continues until\n*    size of  is reached. If  is not specified and table is\n*    empty, the newly inserted row is filled with empty values,\n*    where filling starts at the first column and continues until the\n*    number of columns is reached.  If  is not specified and table\n*    is not empty, the newly inserted row is filled with empty values,\n*    where filling starts at the first column and continues until the\n*    number of non-empty columns is reached.\n*\n*  \n\n The new number of rows after the row insertion.\n*\n*  \n\n Table must have at least one column, which can be empty.\n*  \n\n  must be greater than or equal to 0 and less than\n*    or equal to the number of table rows.\n*  \n\n If table is not empty and  is specified, the size of \n    must be less than or equal to the number of non-empty columns.\n*    This is in order to prevent creation of non-rectangular tables.\n*  \n\n If table is empty and  is specified, the size of  must\n*    be less than or equal to the number of columns.\n*\n*  \n\n The number of rows is increased by one. \n*  \n\n Row indices, of the rows below the inserted row, are invalidated\n*    by being increased by one.\n*\n*  \n\n EmptyContainerException - if table has no columns.\n*  \n\n out_of_range - if  is greater than the number\n*    of table rows.\n*  \n\n out_of_range - if table is not empty and size of  is\n*    greater than the number of non-empty columns.\n*  \n\n out_of_range - if table is empty and size of  is\n*    greater than the number of columns.\n\nC++: ITTable::InsertRow(const unsigned int, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> unsigned int", pybind11::arg("atRowIndex"), pybind11::arg("row"));
		cl.def("FillRow", (void (ITTable::*)(const unsigned int, const class std::vector<std::string, class std::allocator<std::string > > &)) &ITTable::FillRow, "*  Fills, with values, a row at the specified row index, starting at the\n*  the first column.\n*\n*  \n\n - index of the row that is to be filled.\n*  \n\n - values which are to be used to fill in the row.\n*    Filling starts at the first column and continues until size of\n*     is reached.\n*\n*  \n\n None\n*\n*  \n\n  must be greater than or equal to 0 and less than\n*    the number of table rows.\n*  \n\n The size of  must be less than or equal to the number of\n*    non-empty columns. This is in order to prevent creation of\n*    non-rectangular tables.\n*\n*  \n\n None \n*\n*  \n\n out_of_range - if  is greater than or equal to\n*    the number of table rows.\n*  \n\n out_of_range - if size of  is greater than the number\n*    of non-empty columns.\n\nC++: ITTable::FillRow(const unsigned int, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> void", pybind11::arg("rowIndex"), pybind11::arg("row"));
		cl.def("ClearRow", (void (ITTable::*)(const unsigned int)) &ITTable::ClearRow, "*  Sets all cells in the row to empty string.\n*\n*  \n\n - index of the row that is to be cleared.\n*\n*  \n\n None\n*\n*  \n\n  must be greater than or equal to 0 and less than\n*    the number of table rows.\n*\n*  \n\n Number of table rows is unchanged.\n*\n*  \n\n out_of_range - if  is greater than or equal to\n     the number of table rows.\n\nC++: ITTable::ClearRow(const unsigned int) --> void", pybind11::arg("rowIndex"));
		cl.def("DeleteRow", (void (ITTable::*)(const unsigned int)) &ITTable::DeleteRow, "*  Deletes a row with the specified index and shifts, up by one,\n*  all other rows below it.\n*\n*  \n\n - index of the row that is to be deleted.\n*\n*  \n\n None\n*\n*  \n\n  must be greater than or equal to 0 and less than\n*    the number of table rows.\n*\n*  \n\n Number of table rows is reduced by one.\n*  \n\n Row indices of the rows which are below the deleted row are\n*    invalidated by being reduced by one.\n*\n*  \n\n out_of_range - if  is greater than or equal to\n*    the number of table rows.\n\nC++: ITTable::DeleteRow(const unsigned int) --> void", pybind11::arg("rowIndex"));
		cl.def("DeleteRows", (void (ITTable::*)(const class std::vector<unsigned int, class std::allocator<unsigned int> > &)) &ITTable::DeleteRows, "*  Deletes rows with specified indices.\n*\n*  \n\n - indices of rows that are to be deleted.\n*\n*  \n\n None\n*\n*  \n\n indices in  must be greater than or equal to 0 and less\n*    than the number of table rows.\n*\n*  \n\n Number of table rows is reduced by the size of \n  \n\n Row indices of the remaining rows are invalidated by being\n*    appropriatelly adjusted.\n*\n*  \n\n out_of_range - if any row index in  is greater than\n*    or equal to the number of table rows.\n\nC++: ITTable::DeleteRows(const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &) --> void", pybind11::arg("rows"));
		cl.def("GetLastRowIndex", (unsigned int (ITTable::*)()) &ITTable::GetLastRowIndex, "*  Retrieves the row index of the last row in the table.\n*\n*  \n\n None\n*\n*  \n\n The index of the last row in the table.\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n: None\n\nC++: ITTable::GetLastRowIndex() --> unsigned int");
		cl.def("ValidateOptions", (void (ITTable::*)(unsigned int)) &ITTable::ValidateOptions, "C++: ITTable::ValidateOptions(unsigned int) --> void", pybind11::arg("colIndex"));
		cl.def("UpdateIndex", (void (ITTable::*)(const unsigned int, const unsigned int)) &ITTable::UpdateIndex, "C++: ITTable::UpdateIndex(const unsigned int, const unsigned int) --> void", pybind11::arg("indexIndex"), pybind11::arg("rowIndex"));
		cl.def("InsertIndexEntry", (void (ITTable::*)(const unsigned int, const unsigned int)) &ITTable::InsertIndexEntry, "C++: ITTable::InsertIndexEntry(const unsigned int, const unsigned int) --> void", pybind11::arg("indexIndex"), pybind11::arg("rowIndex"));
		cl.def("DeleteIndexEntry", (void (ITTable::*)(const unsigned int, const unsigned int)) &ITTable::DeleteIndexEntry, "C++: ITTable::DeleteIndexEntry(const unsigned int, const unsigned int) --> void", pybind11::arg("indexIndex"), pybind11::arg("rowIndex"));
		cl.def("VerifyColumnsIndices", (void (ITTable::*)(const class std::vector<unsigned int, class std::allocator<unsigned int> > &)) &ITTable::VerifyColumnsIndices, "C++: ITTable::VerifyColumnsIndices(const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &) --> void", pybind11::arg("colIndices"));
		cl.def("FindIndex", (int (ITTable::*)(const class std::vector<unsigned int, class std::allocator<unsigned int> > &)) &ITTable::FindIndex, "C++: ITTable::FindIndex(const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &) --> int", pybind11::arg("colIndices"));
		cl.def("FindFirst", (unsigned int (ITTable::*)(const class std::vector<std::string, class std::allocator<std::string > > &, const class std::vector<unsigned int, class std::allocator<unsigned int> > &, const unsigned int)) &ITTable::FindFirst, "C++: ITTable::FindFirst(const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, const unsigned int) --> unsigned int", pybind11::arg("targets"), pybind11::arg("colIndices"), pybind11::arg("indexIndex"));
		cl.def("Search", [](ITTable &o, class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > & a0, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a1, const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > & a2, const unsigned int  &a3) -> void { return o.Search(a0, a1, a2, a3); }, "", pybind11::arg("res"), pybind11::arg("targets"), pybind11::arg("colIndices"), pybind11::arg("indexIndex"));
		cl.def("Search", (void (ITTable::*)(class std::vector<unsigned int, class std::allocator<unsigned int> > &, const class std::vector<std::string, class std::allocator<std::string > > &, const class std::vector<unsigned int, class std::allocator<unsigned int> > &, const unsigned int, const enum ITTable::eSearchType)) &ITTable::Search, "C++: ITTable::Search(class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, const unsigned int, const enum ITTable::eSearchType) --> void", pybind11::arg("res"), pybind11::arg("targets"), pybind11::arg("colIndices"), pybind11::arg("indexIndex"), pybind11::arg("searchType"));
		cl.def("DeleteIndex", (void (ITTable::*)(const unsigned int)) &ITTable::DeleteIndex, "C++: ITTable::DeleteIndex(const unsigned int) --> void", pybind11::arg("indexIndex"));
		cl.def("Search", [](ITTable &o, class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > & a0, const class std::__1::basic_string<char> & a1, const unsigned int  &a2) -> void { return o.Search(a0, a1, a2); }, "", pybind11::arg("res"), pybind11::arg("target"), pybind11::arg("colIndex"));
		cl.def("Search", (void (ITTable::*)(class std::vector<unsigned int, class std::allocator<unsigned int> > &, const std::string &, const unsigned int, const enum ITTable::eSearchType)) &ITTable::Search, "C++: ITTable::Search(class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, const class std::__1::basic_string<char> &, const unsigned int, const enum ITTable::eSearchType) --> void", pybind11::arg("res"), pybind11::arg("target"), pybind11::arg("colIndex"), pybind11::arg("searchType"));
		cl.def("Clear", (void (ITTable::*)()) &ITTable::Clear, "C++: ITTable::Clear() --> void");
		cl.def("CreateColumn", [](ITTable &o, const unsigned int  &a0) -> void { return o.CreateColumn(a0); }, "", pybind11::arg("atColIndex"));
		cl.def("CreateColumn", (void (ITTable::*)(const unsigned int, const class std::vector<std::string, class std::allocator<std::string > > &)) &ITTable::CreateColumn, "C++: ITTable::CreateColumn(const unsigned int, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> void", pybind11::arg("atColIndex"), pybind11::arg("col"));
		cl.def("CreateColumn", (void (ITTable::*)(const unsigned int, class std::__wrap_iter<const std::string *>, class std::__wrap_iter<const std::string *>)) &ITTable::CreateColumn, "C++: ITTable::CreateColumn(const unsigned int, class std::__1::__wrap_iter<const class std::__1::basic_string<char> *>, class std::__1::__wrap_iter<const class std::__1::basic_string<char> *>) --> void", pybind11::arg("atColIndex"), pybind11::arg("colBeg"), pybind11::arg("colEnd"));
		cl.def("GetOrientation", (enum ITTable::eOrientation (ITTable::*)()) &ITTable::GetOrientation, "C++: ITTable::GetOrientation() --> enum ITTable::eOrientation");
		cl.def("CreateIndex", [](ITTable &o, const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > & a0) -> void { return o.CreateIndex(a0); }, "", pybind11::arg("colIndices"));
		cl.def("CreateIndex", (void (ITTable::*)(const class std::vector<unsigned int, class std::allocator<unsigned int> > &, const unsigned int)) &ITTable::CreateIndex, "C++: ITTable::CreateIndex(const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, const unsigned int) --> void", pybind11::arg("colIndices"), pybind11::arg("unique"));
		cl.def("SetSerializer", (void (ITTable::*)(class Serializer *)) &ITTable::SetSerializer, "*  Utility method, not part of users public API.\n\nC++: ITTable::SetSerializer(class Serializer *) --> void", pybind11::arg("ser"));
		cl.def("WriteObject", (int (ITTable::*)(class Serializer *, int &)) &ITTable::WriteObject, "*  Utility method, not part of users public API.\n\nC++: ITTable::WriteObject(class Serializer *, int &) --> int", pybind11::arg("ser"), pybind11::arg("size"));
		cl.def("GetObject", (int (ITTable::*)(unsigned int, class Serializer *)) &ITTable::GetObject, "*  Utility method, not part of users public API.\n\nC++: ITTable::GetObject(unsigned int, class Serializer *) --> int", pybind11::arg("index"), pybind11::arg("ser"));
		cl.def("Read", (int (ITTable::*)(unsigned int, class Serializer *)) &ITTable::Read, "*  Utility method, not part of users public API.\n\nC++: ITTable::Read(unsigned int, class Serializer *) --> int", pybind11::arg("indexInFile"), pybind11::arg("ser"));
		cl.def("Write", (int (ITTable::*)(class Serializer *, int &)) &ITTable::Write, "*  Utility method, not part of users public API.\n\nC++: ITTable::Write(class Serializer *, int &) --> int", pybind11::arg("ser"), pybind11::arg("size"));
		cl.def("InsertEntry", (void (ITTable::*)(const unsigned int)) &ITTable::InsertEntry, "C++: ITTable::InsertEntry(const unsigned int) --> void", pybind11::arg("rowIndex"));
		cl.def("DeleteEntry", (void (ITTable::*)(const unsigned int)) &ITTable::DeleteEntry, "C++: ITTable::DeleteEntry(const unsigned int) --> void", pybind11::arg("rowIndex"));
		cl.def("GetNumIndices", (unsigned int (ITTable::*)()) &ITTable::GetNumIndices, "*  Utility method, not part of users public API.\n\nC++: ITTable::GetNumIndices() --> unsigned int");

		cl.def("__str__", [](ITTable const &o) -> std::string { std::ostringstream s; s << o; return s.str(); } );
	}
}
