#include <BlockIO.h>
#include <Serializer.h>
#include <TTable.h>
#include <__string>
#include <initializer_list>
#include <ios>
#include <iterator>
#include <locale>
#include <memory>
#include <ostream>
#include <rcsb_types.h>
#include <sstream> // __str__
#include <streambuf>
#include <string>
#include <string_view>
#include <vector>

#include <pybind11/pybind11.h>

#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>);
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*);
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>);
#endif

void bind_rcsb_types(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// eTypeCode file:rcsb_types.h line:20
	pybind11::enum_<eTypeCode>(M(""), "eTypeCode", "")
		.value("eTYPE_CODE_NONE", eTypeCode::eTYPE_CODE_NONE)
		.value("eTYPE_CODE_INT", eTypeCode::eTYPE_CODE_INT)
		.value("eTYPE_CODE_FLOAT", eTypeCode::eTYPE_CODE_FLOAT)
		.value("eTYPE_CODE_STRING", eTypeCode::eTYPE_CODE_STRING)
		.value("eTYPE_CODE_TEXT", eTypeCode::eTYPE_CODE_TEXT)
		.value("eTYPE_CODE_DATETIME", eTypeCode::eTYPE_CODE_DATETIME)
		.value("eTYPE_CODE_BIGINT", eTypeCode::eTYPE_CODE_BIGINT)
		.export_values();

;

	{ // BlockIO file:BlockIO.h line:15
		pybind11::class_<BlockIO, std::shared_ptr<BlockIO>> cl(M(""), "BlockIO", "");
		pybind11::handle cl_type = cl;

		cl.def( pybind11::init( [](){ return new BlockIO(); } ) );
		cl.def("ReadBlock", (unsigned int (BlockIO::*)(const int, const unsigned int)) &BlockIO::ReadBlock, "C++: BlockIO::ReadBlock(const int, const unsigned int) --> unsigned int", pybind11::arg("fd"), pybind11::arg("blockNum"));
		cl.def("WriteBlock", (unsigned int (BlockIO::*)(const int, const unsigned int)) &BlockIO::WriteBlock, "C++: BlockIO::WriteBlock(const int, const unsigned int) --> unsigned int", pybind11::arg("fd"), pybind11::arg("blockNum"));
	}
	// eFileMode file:Serializer.h line:33
	pybind11::enum_<eFileMode>(M(""), "eFileMode", "")
		.value("NO_MODE", eFileMode::NO_MODE)
		.value("READ_MODE", eFileMode::READ_MODE)
		.value("CREATE_MODE", eFileMode::CREATE_MODE)
		.value("UPDATE_MODE", eFileMode::UPDATE_MODE)
		.value("VIRTUAL_MODE", eFileMode::VIRTUAL_MODE)
		.export_values();

;

	{ // Serializer file:Serializer.h line:43
		pybind11::class_<Serializer, std::shared_ptr<Serializer>> cl(M(""), "Serializer", "");
		pybind11::handle cl_type = cl;

		cl.def(pybind11::init([](const class std::__1::basic_string<char> & a0, const enum eFileMode  &a1){ return new Serializer(a0, a1); }), "doc");
		cl.def(pybind11::init<const class std::__1::basic_string<char> &, const enum eFileMode, const bool>(), pybind11::arg("fileName"), pybind11::arg("fileMode"), pybind11::arg("verbose"));

		cl.def("GetNumDataIndices", (unsigned int (Serializer::*)()) &Serializer::GetNumDataIndices, "C++: Serializer::GetNumDataIndices() --> unsigned int");
		cl.def("ReadUInt32", (unsigned int (Serializer::*)(const unsigned int)) &Serializer::ReadUInt32, "C++: Serializer::ReadUInt32(const unsigned int) --> unsigned int", pybind11::arg("index"));
		cl.def("ReadUInt32s", (void (Serializer::*)(class std::vector<unsigned int, class std::allocator<unsigned int> > &, const unsigned int)) &Serializer::ReadUInt32s, "C++: Serializer::ReadUInt32s(class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, const unsigned int) --> void", pybind11::arg("UInt32s"), pybind11::arg("index"));
		cl.def("ReadString", (void (Serializer::*)(std::string &, const unsigned int)) &Serializer::ReadString, "C++: Serializer::ReadString(class std::__1::basic_string<char> &, const unsigned int) --> void", pybind11::arg("retString"), pybind11::arg("index"));
		cl.def("ReadStrings", (void (Serializer::*)(class std::vector<std::string, class std::allocator<std::string > > &, const unsigned int)) &Serializer::ReadStrings, "C++: Serializer::ReadStrings(class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const unsigned int) --> void", pybind11::arg("theStrings"), pybind11::arg("index"));
		cl.def("WriteUInt32", (unsigned int (Serializer::*)(const unsigned int)) &Serializer::WriteUInt32, "C++: Serializer::WriteUInt32(const unsigned int) --> unsigned int", pybind11::arg("theWord"));
		cl.def("WriteUInt32s", (unsigned int (Serializer::*)(const class std::vector<unsigned int, class std::allocator<unsigned int> > &)) &Serializer::WriteUInt32s, "C++: Serializer::WriteUInt32s(const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &) --> unsigned int", pybind11::arg("theWords"));
		cl.def("WriteString", (unsigned int (Serializer::*)(const std::string &)) &Serializer::WriteString, "C++: Serializer::WriteString(const class std::__1::basic_string<char> &) --> unsigned int", pybind11::arg("theString"));
		cl.def("WriteStrings", (unsigned int (Serializer::*)(const class std::vector<std::string, class std::allocator<std::string > > &)) &Serializer::WriteStrings, "C++: Serializer::WriteStrings(const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> unsigned int", pybind11::arg("theStrings"));
		cl.def("UpdateUInt32", (unsigned int (Serializer::*)(const unsigned int, const unsigned int)) &Serializer::UpdateUInt32, "C++: Serializer::UpdateUInt32(const unsigned int, const unsigned int) --> unsigned int", pybind11::arg("theWord"), pybind11::arg("oldIndex"));
		cl.def("UpdateUInt32s", (unsigned int (Serializer::*)(const class std::vector<unsigned int, class std::allocator<unsigned int> > &, const unsigned int)) &Serializer::UpdateUInt32s, "C++: Serializer::UpdateUInt32s(const class std::__1::vector<unsigned int, class std::__1::allocator<unsigned int> > &, const unsigned int) --> unsigned int", pybind11::arg("theWords"), pybind11::arg("oldIndex"));
		cl.def("UpdateString", (unsigned int (Serializer::*)(const std::string &, const unsigned int)) &Serializer::UpdateString, "C++: Serializer::UpdateString(const class std::__1::basic_string<char> &, const unsigned int) --> unsigned int", pybind11::arg("theString"), pybind11::arg("oldIndex"));
		cl.def("UpdateStrings", (unsigned int (Serializer::*)(const class std::vector<std::string, class std::allocator<std::string > > &, const unsigned int)) &Serializer::UpdateStrings, "C++: Serializer::UpdateStrings(const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const unsigned int) --> unsigned int", pybind11::arg("theStrings"), pybind11::arg("oldIndex"));
	}
	{ // TTable file:TTable.h line:41
		pybind11::class_<TTable, std::shared_ptr<TTable>> cl(M(""), "TTable", "* \n\n*\n* \n\n Private class that represents a table of tuples.\n*\n* This class represents a two-dimensional table of cells. Each cell is\n* represented by a text string. Tuples are horizontal table entities\n* identified by tuple indices, which are unsigned integers ranging from zero\n* to the number of tuples minus one. Tuples are vertical table entities\n* identified by tuple indices. The class provides methods for table\n* construction and destruction, assignment operator, tuple and column based\n* methods for addition, insertion, retrieval, update, deletion, cell based\n* methods for update and retrieval and table printing.");
		pybind11::handle cl_type = cl;

		cl.def( pybind11::init( [](){ return new TTable(); } ) );
		cl.def(pybind11::init<TTable const &>());
		cl.def("assign", (class TTable & (TTable::*)(const class TTable &)) &TTable::operator=, "*  Copies a tuple table to another table (assignment operator).\n*\n*  \n\n - reference to the source table\n*\n*  \n\n Reference to the destination table\n*\n*  \n\n None\n*\n*  \n\n Constructed table has the same content as the table\n*    referenced by \n   None\n\nC++: TTable::operator=(const class TTable &) --> class TTable &", pybind11::return_value_policy::automatic, pybind11::arg("inTable"));
		cl.def("Clear", (void (TTable::*)()) &TTable::Clear, "*  Deletes all the content from the table.\n*\n*   None\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*  \n\n Table has 0 columns and 0 tuples.\n*\n*   None\n\nC++: TTable::Clear() --> void");
		cl.def("GetNumTuples", (unsigned int (TTable::*)() const) &TTable::GetNumTuples, "*  Retrieves the number of tuples in the table.\n*\n*   None\n*\n*  \n\n The number of tuples in the table.\n*\n*  \n\n None\n*\n*  \n\n None\n*\n*   None\n\nC++: TTable::GetNumTuples() const --> unsigned int");
		cl.def("AddTuple", [](TTable &o) -> unsigned int { return o.AddTuple(); }, "");
		cl.def("AddTuple", (unsigned int (TTable::*)(const class std::vector<std::string, class std::allocator<std::string > > &)) &TTable::AddTuple, "C++: TTable::AddTuple(const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> unsigned int", pybind11::arg("tuple"));
		cl.def("InsertTuple", [](TTable &o, const unsigned int  &a0) -> void { return o.InsertTuple(a0); }, "", pybind11::arg("tupleIndex"));
		cl.def("InsertTuple", (void (TTable::*)(const unsigned int, const class std::vector<std::string, class std::allocator<std::string > > &)) &TTable::InsertTuple, "*  Inserts a new tuple at the specified tuple index and shifts,\n*    to the right by one, the specified existing tuple and all tuples\n*    after it.\n*\n*  \n\n - the index of the tuple at which the new tuple\n*    is to be inserted\n*  \n\n - optional parameter that contains the values which\n*    are to be used to fill in the newly inserted tuple. If  is\n*    specified, filling starts at column index 0 and continues until size\n*    of  If  is not specified, the newly inserted tuple is\n*    filled with empty values, where filling starts at column index 0 and\n*    ends at column index \"number of columns - 1\".\n*\n*  \n\n None\n*\n*  \n\n  must be greater than 0 and less than or equal to\n*    the number of tuples\n*\n*  \n\n If  is specified, the size of  must be less than or\n*    equal to the number of columns.\n*  \n\n The tuple which comes, in order, before the tuple with name\n*     must be non-empty. This is to prevent creation of\n*    non-rectangular tables.\n*\n*  \n\n If table is empty (0 columns) and  is specified,\n*    the number of columns is set to the size of  Otherwise, the\n*    number of columns is unchanged.\n*\n*  \n\n out_of_range - if  is greater than than the\n*    number of tuples\n*  \n\n out_of_range - if size of  is greater than the number\n*    of columns\n*  \n\n out_of_range - if tuple, which comes, in order, before the\n*    tuple with name  is empty.\n\nC++: TTable::InsertTuple(const unsigned int, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> void", pybind11::arg("tupleIndex"), pybind11::arg("tuple"));
		cl.def("InsertTuple", (void (TTable::*)(const unsigned int, class std::__wrap_iter<const std::string *>, class std::__wrap_iter<const std::string *>)) &TTable::InsertTuple, "C++: TTable::InsertTuple(const unsigned int, class std::__1::__wrap_iter<const class std::__1::basic_string<char> *>, class std::__1::__wrap_iter<const class std::__1::basic_string<char> *>) --> void", pybind11::arg("tupleIndex"), pybind11::arg("tupleBeg"), pybind11::arg("tupleEnd"));
		cl.def("FillTuple", [](TTable &o, const unsigned int  &a0, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a1) -> void { return o.FillTuple(a0, a1); }, "", pybind11::arg("tupleIndex"), pybind11::arg("tuple"));
		cl.def("FillTuple", (void (TTable::*)(const unsigned int, const class std::vector<std::string, class std::allocator<std::string > > &, const unsigned int)) &TTable::FillTuple, "*  Inserts a new tuple at the specified tuple index and shifts,\n*    to the right by one, the specified existing tuple and all tuples\n*    after it.\n*\n*  \n\n - the index of the tuple at which the new tuple\n*    is to be inserted\n*  \n\n - contains the values which are to be used to fill in\n*    the newly inserted tuple. Filling starts at column index 0 and\n*    continues until size of \n  \n\n None\n*\n*  \n\n  must be greater than 0 and less than the number\n*    of tuples\n*\n*  \n\n The size of  must be less than or equal to the number\n*    of columns.\n*  \n\n The tuple which comes, in order, before the tuple with name\n*     must be non-empty. This is to prevent creation of\n*    non-rectangular tables.\n*\n*  \n\n If table is empty (0 columns) and  is specified, the\n*    number of columns is set to the size of  Otherwise, the\n*    number of columns is unchanged.\n*\n*  \n\n out_of_range - if  is greater than than the\n*    number of tuples\n*  \n\n out_of_range - if size of  is greater than the number\n*    of columns\n*  \n\n out_of_range - if tuple, which comes, in order, before the\n*    tuple with name  is empty.\n\nC++: TTable::FillTuple(const unsigned int, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const unsigned int) --> void", pybind11::arg("tupleIndex"), pybind11::arg("tuple"), pybind11::arg("fromColIndex"));
		cl.def("GetTuple", (void (TTable::*)(class std::vector<std::string, class std::allocator<std::string > > &, const unsigned int, const unsigned int, unsigned int)) &TTable::GetTuple, "C++: TTable::GetTuple(class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const unsigned int, const unsigned int, unsigned int) --> void", pybind11::arg("tuple"), pybind11::arg("tupleIndex"), pybind11::arg("fromColIndex"), pybind11::arg("toColIndex"));
		cl.def("GetTuple", (const class std::vector<std::string, class std::allocator<std::string > > & (TTable::*)(const unsigned int)) &TTable::GetTuple, "C++: TTable::GetTuple(const unsigned int) --> const class std::vector<std::string, class std::allocator<std::string > > &", pybind11::return_value_policy::automatic, pybind11::arg("tupleIndex"));
		cl.def("ClearTuple", (void (TTable::*)(const unsigned int)) &TTable::ClearTuple, "*  Sets all cells in the tuple to empty string.\n*\n*  \n\n - the name of the tuple\n*\n*  \n\n None\n*\n*  \n\n  must be non-empty\n*  \n\n Tuple with name  must be present\n*\n*  \n\n Tuple length is unchanged.\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if tuple with name \n    does not exist\n\nC++: TTable::ClearTuple(const unsigned int) --> void", pybind11::arg("tupleIndex"));
		cl.def("DeleteTuple", (void (TTable::*)(const unsigned int)) &TTable::DeleteTuple, "*  Deletes a tuple from the table.\n*\n*  \n\n - the name of the tuple\n*\n*  \n\n None\n*\n*  \n\n  must be non-empty\n*  \n\n Tuple with name  must be present\n*\n*  \n\n The number of table tuples is reduced by one.\n*\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if tuple with name \n    does not exist\n\nC++: TTable::DeleteTuple(const unsigned int) --> void", pybind11::arg("tupleIndex"));
		cl.def("GetNumColumns", (unsigned int (TTable::*)() const) &TTable::GetNumColumns, "*  Retrieves the number of columns in the table.\n*\n*   None\n*\n*  \n\n The number of columns in the table.\n*\n*  \n\n None\n*\n*  \n\n None\n\nC++: TTable::GetNumColumns() const --> unsigned int");
		cl.def("AddColumn", [](TTable &o) -> unsigned int { return o.AddColumn(); }, "");
		cl.def("AddColumn", (unsigned int (TTable::*)(const class std::vector<std::string, class std::allocator<std::string > > &)) &TTable::AddColumn, "*  Adds a new column to the bottom end of the table. For an empty table,\n*  the number of inserted cells is equal to the number of table tuples.\n*  For a non-empty table, the number of inserted cells is equal to the\n*  number of non-empty tuples (this is in order to prevent creation of\n*  non-rectangular tables). The newly added column is, optionally,\n*  filled with values, starting at the first tuple.\n*\n*  \n\n - optional parameter that contains the values which\n*    are to be used to fill in the newly added column. Filling starts at\n*    the first tuple and continues until size of \n  \n\n The new number of columns after the column addition.\n*\n*  \n\n Table must have at least one tuple, which can be empty.\n*  \n\n If table is not empty and  is specified, the size of\n*     must be less than or equal to the number of non-empty\n*    tuples. This is in order to prevent creation of non-rectangular\n*    tables.\n*  \n\n If table is empty and  is specified, the size of\n*     must be less than or equal to the number of tuples.\n*\n*  \n\n The number of columns is increased by one. \n*\n*  \n\n EmptyContainerException - if table has no tuples.\n*  \n\n out_of_range - if table is not empty and size of  is\n*    greater than the number of non-empty tuples.\n*  \n\n out_of_range - if table is empty and size of  is\n*    greater than the number of tuples.\n\nC++: TTable::AddColumn(const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> unsigned int", pybind11::arg("col"));
		cl.def("InsertColumn", [](TTable &o, const unsigned int  &a0) -> unsigned int { return o.InsertColumn(a0); }, "", pybind11::arg("atColIndex"));
		cl.def("InsertColumn", (unsigned int (TTable::*)(const unsigned int, const class std::vector<std::string, class std::allocator<std::string > > &)) &TTable::InsertColumn, "*  Inserts a new column at the specified column index and shifts, down by\n*  one, the old column with the specified column index and all other\n*  columns below it.\n*  For an empty table, the number of inserted cells is equal to the\n*  number of table tuples. For a non-empty table, the number of\n*  inserted cells is equal to the number of non-empty tuples (this is\n*  in order to prevent creation of non-rectangular tables). The newly\n*  inserted column is optionally filled with values, starting at the\n*  first tuple.\n*\n*  \n\n - index of the column at which the new column is\n*    to be inserted. Note: If  is equal to the number of\n*    columns, the operation of this method is equivalent to AddRow().\n*  \n\n - optional parameter that contains the values which\n*    are to be used to fill in the newly inserted column. Filling starts at\n*    the first tuple and continues until size of \n  \n\n The new number of columns after the column insertion.\n*\n*  \n\n Table must have at least one tuple, which can be empty.\n*  \n\n  must be less than or equal to the number of table\n*    columns.\n*  \n\n If table is not empty and  is specified, the size of\n*     must be less than or equal to the number of non-empty\n*    tuples. This is in order to prevent creation of non-rectangular\n*    tables.\n*  \n\n If table is empty and  is specified, the size of\n*     must be less than or equal to the number of tuples.\n*\n*  \n\n The number of columns is increased by one. \n*  \n\n Row indices of the columns which are below the inserted column are\n*    invalidated by being increased by 1.\n*\n*  \n\n EmptyContainerException - if table has no tuples.\n*  \n\n out_of_range - if  is greater than the number\n*    of table columns.\n*  \n\n out_of_range - if table is not empty and size of  is\n*    greater than the number of non-empty tuples.\n*  \n\n out_of_range - if table is empty and size of  is\n*    greater than the number of tuples.\n\nC++: TTable::InsertColumn(const unsigned int, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &) --> unsigned int", pybind11::arg("atColIndex"), pybind11::arg("col"));
		cl.def("InsertColumn", (void (TTable::*)(const unsigned int, class std::__wrap_iter<const std::string *>, class std::__wrap_iter<const std::string *>)) &TTable::InsertColumn, "C++: TTable::InsertColumn(const unsigned int, class std::__1::__wrap_iter<const class std::__1::basic_string<char> *>, class std::__1::__wrap_iter<const class std::__1::basic_string<char> *>) --> void", pybind11::arg("atColIndex"), pybind11::arg("colBeg"), pybind11::arg("colEnd"));
		cl.def("FillColumn", [](TTable &o, const unsigned int  &a0, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > & a1) -> void { return o.FillColumn(a0, a1); }, "", pybind11::arg("colIndex"), pybind11::arg("col"));
		cl.def("FillColumn", (void (TTable::*)(const unsigned int, const class std::vector<std::string, class std::allocator<std::string > > &, const unsigned int)) &TTable::FillColumn, "*  Fills, with values, a column at the specified column index, starting\n*  at the the first tuple.\n*\n*  \n\n - index of the column that is to be filled.\n*  \n\n - values which are to be used to fill in the column.\n*    Filling starts at the first tuple and continues until size of\n*    \n  \n\n None\n*\n*  \n\n  must be greater than 0 and less than the number of\n*    table columns.\n*  \n\n The size of  must be less than or equal to the number of\n*    non-empty tuples. This is in order to prevent creation of\n*    non-rectangular tables.\n*\n*  \n\n None \n*\n*  \n\n out_of_range - if  is greater than or equal to\n*    the number of table columns.\n*  \n\n out_of_range - if size of  is greater than the\n*    number of non-empty tuples.\n\nC++: TTable::FillColumn(const unsigned int, const class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const unsigned int) --> void", pybind11::arg("colIndex"), pybind11::arg("col"), pybind11::arg("fromTupleIndex"));
		cl.def("FillColumn", [](TTable &o, const unsigned int  &a0, class std::__1::__wrap_iter<const class std::__1::basic_string<char> *>  const &a1, class std::__1::__wrap_iter<const class std::__1::basic_string<char> *>  const &a2) -> void { return o.FillColumn(a0, a1, a2); }, "", pybind11::arg("colIndex"), pybind11::arg("colBeg"), pybind11::arg("colEnd"));
		cl.def("FillColumn", (void (TTable::*)(const unsigned int, class std::__wrap_iter<const std::string *>, class std::__wrap_iter<const std::string *>, const unsigned int)) &TTable::FillColumn, "C++: TTable::FillColumn(const unsigned int, class std::__1::__wrap_iter<const class std::__1::basic_string<char> *>, class std::__1::__wrap_iter<const class std::__1::basic_string<char> *>, const unsigned int) --> void", pybind11::arg("colIndex"), pybind11::arg("colBeg"), pybind11::arg("colEnd"), pybind11::arg("fromTupleIndex"));
		cl.def("GetColumn", (void (TTable::*)(class std::vector<std::string, class std::allocator<std::string > > &, const unsigned int, const unsigned int, unsigned int)) &TTable::GetColumn, "*  Retrieves the values in the specified column. \n*\n*  \n\n - retrieved column values\n*  \n\n - index of the column which values are to be\n*    retrieved.\n*  \n\n - optional parameter which specifies the\n*    column location of the first cell to be retrieved. If not specified\n*    the first tuple cell is used.\n*  \n\n - optional parameter which specifies the\n*    column location of the last cell to be retrieved. If not specified\n*    the last non-empty-tuple cell is used.\n*\n*  \n\n None\n*\n*  \n\n  must be greater than 0 and less than the number of\n*    table columns.\n*  \n\n If  is specified, the tuple with name\n*     must be present and must be non-empty\n*  \n\n If  is specified, the tuple with name\n*     must be present and must be non-empty\n*  \n\n If  is different than  it must come\n*    prior to it in the tuple order.\n*\n*  \n\n None\n*\n*  \n\n out_of_range - if  is less than 0 or greater\n*    than or equal to the number of table columns.\n*  \n\n NotFoundException - If  is specified and\n*    tuple with name  does not exist\n*  \n\n NotFoundException - If  is specified and\n*    tuple with name  does not exist\n*  \n\n out_of_range - If  is specified and\n*    tuple with name  exists but is empty\n*  \n\n out_of_range - If  is specified and\n*    tuple with name  exists but is empty\n*  \n\n out_of_range - if  is different than\n*     and it comes after it in the tuple order.\n\nC++: TTable::GetColumn(class std::__1::vector<class std::__1::basic_string<char>, class std::__1::allocator<class std::__1::basic_string<char> > > &, const unsigned int, const unsigned int, unsigned int) --> void", pybind11::arg("col"), pybind11::arg("colIndex"), pybind11::arg("fromTupleIndex"), pybind11::arg("toTupleIndex"));
		cl.def("ClearColumn", (void (TTable::*)(const unsigned int)) &TTable::ClearColumn, "*  Sets all cells in the column to empty string.\n*\n*  \n\n - index of the column that is to be cleared.\n*\n*  \n\n None\n*\n*  \n\n  must be greater than 0 and less than the number of\n*    table columns.\n*\n*  \n\n None\n*\n*  \n\n out_of_range - if  is less than 0 or greater\n*    than or equal to the number of table columns.\n\nC++: TTable::ClearColumn(const unsigned int) --> void", pybind11::arg("colIndex"));
		cl.def("DeleteColumn", (void (TTable::*)(const unsigned int)) &TTable::DeleteColumn, "*  Deletes a column with the specified column index.\n*\n*  \n\n - index of the column that is to be deleted.\n*\n*  \n\n None\n*\n*  \n\n  must be greater than 0 and less than the number of\n*    table columns.\n*\n*  \n\n Number of table columns is reduced by 1.\n*  \n\n Row indices of the columns which are below the deleted column are\n*    invalidated by being reduced by 1.\n*\n*  \n\n out_of_range - if  is less than 0 or greater\n*    than or equal to the number of table columns.\n\nC++: TTable::DeleteColumn(const unsigned int) --> void", pybind11::arg("colIndex"));
		cl.def("__call__", (std::string & (TTable::*)(const unsigned int, const unsigned int)) &TTable::operator(), "*  Updates a cell in the table.\n*\n*  \n\n - column index of the cell that is to be updated.\n*  \n\n - the name of the tuple\n*\n*  \n\n None\n*\n*  \n\n  must be greater than 0 and less than the number of\n*    table columns.\n*  \n\n  must be non-empty\n*  \n\n Tuple with name  must be present\n*\n*  \n\n None\n*\n*  \n\n out_of_range - if  is less than 0 or greater\n*    than or equal to the number of table columns.\n*  \n\n EmptyValueException - if  is empty\n*  \n\n NotFoundException - if tuple with name \n    does not exist\n\nC++: TTable::operator()(const unsigned int, const unsigned int) --> std::string &", pybind11::return_value_policy::automatic, pybind11::arg("tupleIndex"), pybind11::arg("colIndex"));
		cl.def("Write", (int (TTable::*)(class Serializer *, unsigned int &)) &TTable::Write, "C++: TTable::Write(class Serializer *, unsigned int &) --> int", pybind11::arg("ser"), pybind11::arg("size"));
		cl.def("Read", (int (TTable::*)(unsigned int, class Serializer *)) &TTable::Read, "C++: TTable::Read(unsigned int, class Serializer *) --> int", pybind11::arg("index"), pybind11::arg("ser"));

		cl.def("__str__", [](TTable const &o) -> std::string { std::ostringstream s; s << o; return s.str(); } );
	}
}
